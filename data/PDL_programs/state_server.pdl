PROGRAM state_server NOHOLD, &PA, STACK = 10000
  ---------------------------------------------------------------
  --- Author: LMS
  --- Brief: Robot state server publishes the information of robot
  --- state over TCP/IP communication
  ---------------------------------------------------------------

TYPE
  ---------------------------------------------------------------
  --- Record: STATE_MESSAGE_TYPE
  --- Brief: Structure for describing the state message.
  ---------------------------------------------------------------
  STATE_MESSAGE_TYPE = RECORD
    timestamp : INTEGER                   -- UNIX Timestamp as returned from CLOCK Built-In Function (11.41 pdl manual)
    robot_status: STRING[1]               -- Current status of the robot (TERMINATE:T, READY:R, MOVING:M, CANCELING:C, SUCCEEDED:S, ERROR:E)
    joint_position : ARRAY[6] OF REAL     -- The value of each joint in degrees as returned from ARM_JNTP function
    ee_position : ARRAY[6] OF REAL        -- The value of the End Effector Position as an array
    -- TODO add more attributes at state msg
  ENDRECORD

CONST
  ci_dv_tcp_accept = 29                   -- DV_CNTRL code for port to socket connection
  ci_dv_tcp_connect = 30                  -- DV_CNTRL code to activate TCP connection (TCP go UP)
  ci_dv_tcp_disconnect = 31               -- DV_CNTRL code to deactivate TCP connection (TCP go DOWN)
  ci_local_port = 1104                    -- TCP server "listening" port (local to the server)
  cs_main_log = '[STATE_SERVER] '         -- Name for main loop used in LUN_CRT
  ci_verbose = 1                          -- Level of logging
  ci_status_msg_type = 0x1                -- Status message type
  ci_publish_frequency = 200              -- The frequency in Hz that will publish the state message. 25 Hz is ideal for real robot communication.
VAR
  -- Shared variables
  -- from others
  ms_state:  STRING[1] EXPORTED FROM motion_server  -- Shared variable for showing the status (TERMINATE:T, READY:R, MOVING:M, SUCCEEDED:S, ERROR:E)
  shutdown: BOOLEAN EXPORTED FROM motion_server
  -- exporting to others
  ss_state:  STRING[1] EXPORTED FROM state_server -- State server status (TERMINATE:T, READY:R, ERROR:E)
  -- Global variables
  vs_server_host : STRING[100] NOSAVE      -- Server IP address
  vi_server_netlun : INTEGER NOSAVE        -- TCP socket identifier
  vs_screen_lun : INTEGER                  -- Output screen identifier
  vb_comm_success : BOOLEAN                -- Communication status flag
  state_message : STATE_MESSAGE_TYPE       -- The state message that will be published

  -- Declaration of shared functions
ROUTINE tcp_server_accept(netlun, port, screenlun, verbose : INTEGER; log_tag : STRING) EXPORTED FROM pdl_tcp_functions
ROUTINE tcp_server_disconnect(netlun, screenlun, verbose : INTEGER; log_tag : STRING) EXPORTED FROM pdl_tcp_functions

  --------------------------------------------------------------------
  --- Routine: throw_error
  --- Brief: Update the state machine of the robot
  --------------------------------------------------------------------
ROUTINE throw_error(error_msg : STRING)
BEGIN
   ss_state := 'E' --ERROR
   WRITE vs_screen_lun (cs_main_log, '[ERROR] : ', error_msg, NL)
END throw_error


  ---------------------------------------------------------------
  --- Routine: publish_state_message
  --- Brief: Collects and sends the status information
  ---------------------------------------------------------------
ROUTINE publish_state_message : BOOLEAN
VAR
  t_jntp : JOINTPOS
  t_i : INTEGER
  ee_pos : POSITION
  roll : REAL
  pitch : REAL
  yaw : REAL
BEGIN

  state_message.timestamp := CLOCK

  SELECT ss_state OF
   case('E'): -- error in state server
      state_message.robot_status := 'E'
   case('T'): -- terminate state server
      state_message.robot_status := 'T'
   ELSE: -- otherwise return motion server state
      state_message.robot_status := ms_state
  ENDSELECT
  t_jntp := ARM_JNTP
  FOR t_i := 1 TO 6 DO
    state_message.joint_position[t_i] := t_jntp[t_i]
  ENDFOR
  JNTP_TO_POS(t_jntp, ee_pos)
  POS_GET_RPY(ee_pos, roll, pitch, yaw)
  state_message.ee_position[1] := ee_pos.x
  state_message.ee_position[2] := ee_pos.y
  state_message.ee_position[3] := ee_pos.z
  state_message.ee_position[4] := roll
  state_message.ee_position[5] := pitch
  state_message.ee_position[6] := yaw

  WRITE vi_server_netlun (state_message.timestamp, state_message.robot_status, state_message.joint_position[1], state_message.joint_position[2], state_message.joint_position[3], state_message.joint_position[4], state_message.joint_position[5], state_message.joint_position[6], state_message.ee_position[1], state_message.ee_position[2], state_message.ee_position[3], state_message.ee_position[4], state_message.ee_position[5], state_message.ee_position[6])

  RETURN(TRUE)

END publish_state_message

---------------------------------------------------------------
--- Routine: client_disconnects_handling
--- Brief: This routine called when the client disconnects
--- FIXME Currently not used
---------------------------------------------------------------
ROUTINE client_disconnects_handling
BEGIN
  IF ci_verbose = 1 THEN
    WRITE vs_screen_lun (cs_main_log, 'Client disconnected')
  ENDIF
END client_disconnects_handling

--ROUTINE reset_connection
--BEGIN
--  IF ci_verbose = 1 THEN
--    WRITE vs_screen_lun (cs_main_log, 'State Server RESETTING')
--  ENDIF
--  CLOSE FILE vi_server_netlun
--  DELAY 10
--  -- opens the socket
--  OPEN FILE vi_server_netlun ('NETT:', 'rw'),
--    WITH $FL_BINARY = TRUE,
--  ENDOPEN
--  tcp_server_accept((vi_server_netlun), ci_local_port, vs_screen_lun, ci_verbose, cs_main_log)
--  EXIT CYCLE
--END reset_connection

  ------------------
  ---- MAIN LOOP
  ------------------
BEGIN

  vb_comm_success := TRUE       -- init communication status flag
  vs_server_host := $NET_L[1]   -- get IP from controller settings
  vs_screen_lun := LUN_CRT      -- define output

  WRITE vs_screen_lun (NL, "------" , NL, 'Robot State Server starting... ', NL)

  -- opens the socket
  OPEN FILE vi_server_netlun ('NETT:', 'rw'),
    WITH $FL_BINARY = TRUE,
  ENDOPEN

  --CONDITION[1]:
  --  WHEN ANYERROR DO
  --    reset_connection
  --ENDCONDITION
  --ENABLE CONDITION[1]

  $BASE := POS(0.0,0.0,0.0,0.0,0.0,0.0,'')
  $UFRAME := POS(0.0,0.0,0.0,0.0,0.0,0.0,'')
  $TOOL := POS(0.0,0.0,0.0,0.0,0.0,0.0,'')

  IF VAR_UNINIT(ss_state) THEN
    WRITE LUN_CRT (cs_main_log, 'Initialize shared variable ss_status to READY', NL)
    ss_state := 'R' -- READY
  ENDIF
  IF VAR_UNINIT(shutdown) THEN
    WRITE LUN_CRT (cs_main_log, 'Initialize shutdown to FALSE', NL)
    shutdown := FALSE -- FALSE
  ENDIF

  WRITE vs_screen_lun (cs_main_log, 'Server Address : ', vs_server_host, NL)
  WRITE vs_screen_lun (cs_main_log, 'Server Port    :', ci_local_port, NL)

  REPEAT

    WRITE vs_screen_lun (cs_main_log, 'Waiting for connections...', NL)

    tcp_server_accept((vi_server_netlun), ci_local_port, vs_screen_lun, ci_verbose, cs_main_log)

    WRITE vs_screen_lun (cs_main_log, 'Starting cycle...', NL)

    ss_state := 'R'  -- set to READY

    -- Publish state message loop stops when a client send terminate message and the status goes 'T'

    WHILE ss_state <> 'T' DO

      vb_comm_success := publish_state_message
      DELAY ROUND((1 / ci_publish_frequency ) * 1000)

    ENDWHILE  -- Terminate while

    WRITE vs_screen_lun (cs_main_log, 'Connection closed.', NL)
    DELAY 500
    WRITE vs_screen_lun (NL, cs_main_log, 'Restarting Robot State Server ... ', NL)

  UNTIL shutdown -- Main loop

  CLOSE FILE vi_server_netlun

END state_server