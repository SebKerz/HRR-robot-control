PROGRAM motion_handler HOLD, &PA, PROG_ARM=1
  ---------------------------------------------------------------
  --- Author: LMS
  --- Brief: Robot motion handler for executing motion commands
  --- which are received from motion server
  ---------------------------------------------------------------

TYPE
---------------------------------------------------------------
--- Node: JOINT_NODE
--- Brief: Structure for describing an joint value .
---------------------------------------------------------------
  JOINT_NODE = NODEDEF
    $MAIN_JNTP
    $LIN_SPD
  ENDNODEDEF
---------------------------------------------------------------
--- Node: POSE_NODE
--- Brief: Structure for describing an pose value .
---------------------------------------------------------------
  POSE_NODE = NODEDEF
    $MAIN_POS
    $LIN_SPD
  ENDNODEDEF

CONST
  cs_main_log = '[MOTION_HANDLER] '     -- Name for main loop used in LUN_CRT
  ci_verbose = 1                        -- Level of logging
  ci_receive_frequency = 200            -- The loop frequency in Hz of main server. THIS NEEDS TO BE IDENTICAL TO THE ROS PARAMETER!
  sns_dt = 5                            -- the SENSOR TRACKING update time delta in ms (needs to be identical to 1000 / ci_receive_frequency)

VAR
  -- Shared variables
  ss_state: STRING[1] EXPORTED FROM state_server
  ms_state: STRING[1] EXPORTED FROM motion_server
  ss_motion_type: STRING[1] EXPORTED FROM motion_server
  shutdown: BOOLEAN EXPORTED FROM motion_server

  sp_joint_trajectory: PATH of JOINT_NODE EXPORTED FROM motion_server   -- Shared variable for the joint trajectory that will be executed
  sp_cartesian_trajectory: PATH of POSE_NODE EXPORTED FROM motion_server   -- Shared variable for the pose trajectory that will be executed
  sar_cartesian_correction : ARRAY[6] OF REAL EXPORTED FROM motion_server
  sar_ofst : ARRAY[6] OF REAL

  sb_enable_robot : BOOLEAN EXPORTED FROM motion_server
  sb_reset_motion : BOOLEAN EXPORTED FROM motion_server
  sb_terminate : BOOLEAN EXPORTED FROM motion_server
  first_snstrk : BOOLEAN EXPORTED FROM motion_server
  sem_exec : SEMAPHORE EXPORTED FROM motion_server NOSAVE

  -- Global variables
  vs_screen_lun : INTEGER                             -- Output screen identifier
  t_i : INTEGER

  -- Declaration of shared functions
ROUTINE throw_error(error_msg : STRING) EXPORTED FROM motion_server
ROUTINE print_joint_trajectory(trajectory: PATH of JOINT_NODE) EXPORTED FROM motion_server
ROUTINE print_cartesian_trajectory(trajectory: PATH of POSE_NODE) EXPORTED FROM motion_server
ROUTINE clear_joint_trajectory EXPORTED FROM motion_server
ROUTINE clear_cartesian_trajectory EXPORTED FROM motion_server

  ---------------------------------------------------------------
  --- Routine: set_succeeded_state
  --- Brief: Sets shared variable tha keeping the robot's state to
  --- SUCCEEDED
  ---------------------------------------------------------------
ROUTINE set_succeeded_state
BEGIN
  IF ms_state = 'M' THEN
    ms_state := 'S' -- Succeeded state
    sb_enable_robot := FALSE
    LOCK
    CANCEL ALL
    UNLOCK
    RESUME
    clear_joint_trajectory
    clear_cartesian_trajectory
    $SENSOR_ENBL := FALSE
    DELAY 50
    ms_state := 'R'   -- Turns again to ready
    WRITE vs_screen_lun (cs_main_log, 'Robot motion succeeded ready to receive new command.', NL)
  ENDIF
END set_succeeded_state

  --------------------------------------------------------------------
  --- Routine: reset_motion
  --- Brief: Cancels the existing motion and resets
  --------------------------------------------------------------------
ROUTINE reset_motion
BEGIN
  WRITE vs_screen_lun (cs_main_log, 'Cancel current executed motion', NL)
  ms_state := 'C' -- CANCELING state
  sb_enable_robot := FALSE
  first_snstrk := TRUE
  ss_motion_type := 'R'
  CANCEL sem_exec
  SIGNAL sem_exec
  LOCK
  CANCEL ALL
  UNLOCK
  RESUME
  clear_joint_trajectory
  clear_cartesian_trajectory
  FOR t_i :=1 TO 6 DO
    sar_cartesian_correction[t_i] := 0
  ENDFOR
  $SENSOR_ENBL := FALSE
  DELAY 50
  ms_state := 'R'  -- Turns again to ready
  CANCEL sem_exec
  SIGNAL sem_exec
  first_snstrk := TRUE
  sb_enable_robot := FALSE
  sb_reset_motion := FALSE
END reset_motion

  --------------------------------------------------------------------
  --- Routine: terminate motion
  --- Brief: Cancels the existing motion and resets
  --------------------------------------------------------------------
ROUTINE terminate
BEGIN
  WRITE vs_screen_lun (cs_main_log, 'Cancel current executed motion', NL)
  ms_state := 'C' -- CANCELING state
  sb_enable_robot := FALSE
  LOCK
  CANCEL ALL
  UNLOCK
  RESUME
  clear_joint_trajectory
  clear_cartesian_trajectory
  $SENSOR_ENBL := FALSE
  DELAY 50
  ss_state := 'T' -- Terminate state server
  ms_state := 'T' -- Terminate motion server
END terminate

  ------------------
  ---- MAIN LOOP
  ------------------
BEGIN
  vs_screen_lun := LUN_CRT      -- define output

  -- Condition for stopping -> resetting the executed motion
  CONDITION[1]:
    WHEN sb_reset_motion=TRUE DO
      reset_motion
  ENDCONDITION

  ENABLE CONDITION[1]

  -- Condition for terminating the program
  CONDITION[2]:
    WHEN sb_terminate=TRUE DO
      terminate
  ENDCONDITION
  ENABLE CONDITION[2]

  clear_joint_trajectory
  clear_cartesian_trajectory

  $SENSOR_TYPE := 7   --External sensor in relative mode and TOOL reference
  FOR t_i :=1 TO 6 DO
    $SENSOR_CNVRSN[t_i] := 1
    $SENSOR_GAIN[t_i] := 50
    sar_cartesian_correction[t_i] := 0
  ENDFOR
  $SENSOR_TIME :=  sns_dt     -- Deviation distribution in time. should be set wrt update rate
  $SENSOR_OFST_LIM[1] := 5000  -- Translation maximum limit
  $SENSOR_OFST_LIM[2] := 8000  -- Rotation maximum limit
  $SENSOR_ENBL := FALSE
  SENSOR_TRK(TRUE, 1)


  $TURN_CARE := TRUE -- Check the configuration turns

  LOCK
  CANCEL ALL
  UNLOCK
  RESUME

  IF VAR_UNINIT(shutdown) THEN
    WRITE LUN_CRT (cs_main_log, 'Initialize shutdown to FALSE', NL)
    shutdown := FALSE -- FALSE
  ENDIF

  WHILE TRUE DO

    -- Wait until robot new motion command received

    WHILE (ms_state <> 'M') DO
      DELAY ROUND((1 / ci_receive_frequency ) * 1000)
    ENDWHILE -- Wait for motion command loop
    WHILE (sb_enable_robot = FALSE) DO
      DELAY ROUND((1 / ci_receive_frequency ) * 1000)
    ENDWHILE -- Wait for motion command loop

    SELECT ss_motion_type OF
      CASE ('J'):
        $SENSOR_ENBL := FALSE
        IF PATH_LEN(sp_joint_trajectory) > 0 THEN
          WRITE vs_screen_lun (cs_main_log, 'Joint Trajectory command will execute', NL)
          print_joint_trajectory(sp_joint_trajectory)

          MOVE ALONG sp_joint_trajectory,
            -- WITH $SEG_FLY = TRUE
            -- WITH $LIN_SPD=sp_joint_trajectory.NODE[1].$LIN_SPD, $SPD_EMT=SPD_LIN
          ENDMOVE
          set_succeeded_state
        ENDIF
      CASE ('C'):
        $SENSOR_ENBL := FALSE
        IF PATH_LEN(sp_cartesian_trajectory) > 0 THEN
          WRITE vs_screen_lun (cs_main_log, 'Cartesian Trajectory command will execute', NL)
          print_cartesian_trajectory(sp_cartesian_trajectory)
          MOVE ALONG sp_cartesian_trajectory,
            -- WITH $SEG_FLY = TRUE
            -- WITH $LIN_SPD=sp_joint_trajectory.NODE[1].$LIN_SPD, $SPD_EMT=SPD_LIN
          ENDMOVE
          set_succeeded_state
        ENDIF
      CASE ('S'):
        WAIT sem_exec
        $SENSOR_ENBL := TRUE
        SENSOR_SET_DATA(sar_cartesian_correction, 1)
        SENSOR_GET_OFST(sar_ofst, 1)
        SIGNAL sem_exec
      CASE ('R'):
        WRITE vs_screen_lun (cs_main_log, 'Weird semaphor', NL)
        reset_motion
      ELSE:
        WRITE vs_screen_lun (cs_main_log, 'Weird semaphor', NL)
        reset_motion
    ENDSELECT

  ENDWHILE -- Main loop

  DELAY 1000
END motion_handler