PROGRAM motion_server NOHOLD, &PA, STACK = 10001
  ---------------------------------------------------------------
  --- Author: LMS
  --- Brief: Robot motion server for handling motion commands
  --- over TCP/IP communication
  ---------------------------------------------------------------

TYPE
  ---------------------------------------------------------------
  --- Record: MOTION_MESSAGE_TYPE
  --- Brief: Structure for describing the motion message.
  ---------------------------------------------------------------
  MOTION_MESSAGE_TYPE = RECORD
    id : INTEGER                        -- Unique identifier of the message
    message_type : STRING[1]            -- Specifier for the type of incoming msg : (T : terminate, R : reset, M : moving, X : cancel)
    motion_type : STRING[1]             -- Valid values are represented by the predefined constants S for Sensor Tracking, X for CANCEL MOTION
    linear_velocity : REAL              -- $LIN_SPD (in m/s)
    trajectory_size : INTEGER           -- Shows how many points are included in trajectory. The default is 1 for performing one motion
    joint_traj_point : ARRAY[6] OF REAL   -- The goal of each joint in degrees
    cart_traj_point : ARRAY[6] OF REAL    -- The goal in cartesian position relative to BASE FRAME
    sensor_tracking_correction : ARRAY[6] OF REAL        -- The cartesian correction relative to BASE FRAME
  ENDRECORD


  ---------------------------------------------------------------
  --- Node: JOINT_NODE
  --- Brief: Structure for describing an joint value .
  ---------------------------------------------------------------
  JOINT_NODE = NODEDEF
    $MAIN_JNTP
    $LIN_SPD
  ENDNODEDEF

  POSE_NODE = NODEDEF
    $MAIN_POS
    $LIN_SPD
  ENDNODEDEF

CONST
  ci_dv_tcp_accept = 29               -- DV_CNTRL code for port to socket connection
  ci_dv_tcp_connect = 30              -- DV_CNTRL code to activate TCP connection (TCP go UP)
  ci_dv_tcp_disconnect = 31           -- DV_CNTRL code to deactivate TCP connection (TCP go DOWN)
  ci_local_port = 1105                -- TCP server "listening" port (local to the server)
  cs_main_log = '[MOTION_SERVER] '    -- Name for main loop used in LUN_CRT
  ci_verbose = 1                      -- Level of logging
  ci_receive_frequency = 200          -- The loop frequency in Hz of main server. THIS NEEDS TO BE IDENTICAL TO THE ROS PARAMETER!

VAR
  -- Shared variables from other files
  ss_state: STRING[1] EXPORTED FROM state_server        -- Shared variable for showing the status (TERMINATE:T, READY:R, MOVING:M, CANCELING:C, SUCCEEDED:S, ERROR:E)
  -- SHared variables to other files
  ms_state: STRING[1] EXPORTED FROM motion_server        -- Shared variable for showing the status (TERMINATE:T, READY:R, MOVING:M, CANCELING:C, SUCCEEDED:S, ERROR:E)
  ss_motion_type: STRING[1] EXPORTED FROM motion_server  -- Shared variable for showing the type of motion (JOINT:J, CARTESIAN:C S:Sensor Tracking)
  shutdown: BOOLEAN EXPORTED FROM motion_server

  sp_joint_trajectory: PATH of JOINT_NODE EXPORTED FROM motion_server      -- Shared variable for the joint trajectory that will be executed
  sp_cartesian_trajectory: PATH of POSE_NODE EXPORTED FROM motion_server   -- Shared variable for the pose trajectory that will be executed
  sar_cartesian_correction : ARRAY[6] OF REAL EXPORTED FROM motion_server  -- Shared variable for the sensor tracking correction

  sb_enable_robot : BOOLEAN EXPORTED FROM motion_server  -- Shared variable to show that the robot is allowed to move
  sb_reset_motion : BOOLEAN EXPORTED FROM motion_server  -- Shared flag to cancel the motion and then reset
  sb_terminate : BOOLEAN EXPORTED FROM motion_server     -- shared flag that will terminate all pdl programs
  first_snstrk : BOOLEAN EXPORTED FROM motion_server
  sem_exec : SEMAPHORE EXPORTED FROM motion_server NOSAVE

  -- Global variables
  vs_server_host : STRING[100] NOSAVE   -- Server IP address
  vi_server_netlun : INTEGER NOSAVE     -- TCP socket identifier
  vs_screen_lun : INTEGER               -- Output screen identifier
  vb_comm_success : BOOLEAN             -- Communication status flag


  -- Declaration of shared functions
ROUTINE tcp_server_accept(netlun, port, screenlun, verbose : INTEGER; log_tag : STRING) EXPORTED FROM pdl_tcp_functions
ROUTINE tcp_server_disconnect(netlun, screenlun, verbose : INTEGER; log_tag : STRING) EXPORTED FROM pdl_tcp_functions

ROUTINE throw_error(error_msg : STRING) EXPORTED FROM motion_server

ROUTINE print_joint_trajectory(trajectory: PATH of JOINT_NODE) EXPORTED FROM motion_server
ROUTINE print_cartesian_trajectory(trajectory: PATH of POSE_NODE) EXPORTED FROM motion_server
ROUTINE clear_joint_trajectory EXPORTED FROM motion_server
ROUTINE clear_cartesian_trajectory EXPORTED FROM motion_server


  --------------------------------------------------------------------
  --- Routine: throw_error
  --- Brief: Update the state machine of the robot
  --------------------------------------------------------------------
ROUTINE throw_error(error_msg : STRING)
BEGIN
   ms_state := 'E' --ERROR status
   WRITE vs_screen_lun (cs_main_log, '[ERROR] : ', error_msg, NL)
END throw_error

  --------------------------------------------------------------------
  --- Routine: append_to_joint_trajectory
  --- Brief: Appends new point to shared PATH variable sp_joint_trajectory
  --------------------------------------------------------------------
ROUTINE append_to_joint_trajectory(new_joint_point: JOINTPOS; linear_vel: REAL ;trajectory_index: INTEGER; trajectory_size: INTEGER): BOOLEAN
VAR
  t_i : INTEGER
BEGIN

  -- Checks if index is within the max limits of the trajectory
  IF trajectory_index > trajectory_size THEN
    RETURN(FALSE)
  ENDIF

  NODE_APP(sp_joint_trajectory) -- Appends uninitialized nodes to the end of trajectory

  sp_joint_trajectory.NODE[trajectory_index].$MAIN_JNTP := new_joint_point
  sp_joint_trajectory.NODE[trajectory_index].$LIN_SPD := linear_vel

  RETURN(TRUE)
END append_to_joint_trajectory

  --------------------------------------------------------------------
  --- Routine: append_to_cartesian_trajectory
  --- Brief: Appends new point to shared PATH variable sp_joint_trajectory
  --------------------------------------------------------------------
ROUTINE append_to_cartesian_trajectory(new_pose_point: POSITION; linear_vel: REAL ;trajectory_index: INTEGER; trajectory_size: INTEGER): BOOLEAN
VAR
  t_i : INTEGER
BEGIN

  -- Checks if index is within the max limits of the trajectory
  IF trajectory_index > trajectory_size THEN
    RETURN(FALSE)
  ENDIF

  NODE_APP(sp_cartesian_trajectory) -- Appends uninitialized nodes to the end of trajectory
  sp_cartesian_trajectory.NODE[trajectory_index].$MAIN_POS := new_pose_point
  sp_cartesian_trajectory.NODE[trajectory_index].$LIN_SPD := linear_vel

  RETURN(TRUE)
END append_to_cartesian_trajectory

  --------------------------------------------------------------------
  --- Routine: clear_joint_trajectory
  --- Brief: Deletes all points from the shared PATH variable sp_joint_trajectory
  --------------------------------------------------------------------
ROUTINE clear_joint_trajectory
BEGIN
  IF PATH_LEN(sp_joint_trajectory) > 0 THEN
    NODE_DEL(sp_joint_trajectory, 1, PATH_LEN(sp_joint_trajectory))
  ENDIF
END clear_joint_trajectory

  --------------------------------------------------------------------
  --- Routine: clear_cartesian_trajectory
  --- Brief: Deletes all points from the shared PATH variable sp_joint_trajectory
  --------------------------------------------------------------------
ROUTINE clear_cartesian_trajectory
BEGIN
  IF PATH_LEN(sp_cartesian_trajectory) > 0 THEN
    NODE_DEL(sp_cartesian_trajectory, 1, PATH_LEN(sp_cartesian_trajectory))
  ENDIF
END clear_cartesian_trajectory

  --------------------------------------------------------------------
  --- Routine: print_joint_trajectory
  --- Brief: Prints all points of a PATH variable
  --------------------------------------------------------------------
ROUTINE print_joint_trajectory(trajectory: PATH of JOINT_NODE)
VAR
  t_i: INTEGER
BEGIN
  WRITE vs_screen_lun (cs_main_log, 'Trajectory :', NL)
  FOR t_i := 1 TO PATH_LEN(trajectory) DO
    WRITE vs_screen_lun (cs_main_log, 'Joint Traj Point ', t_i ,' ', trajectory.NODE[t_i].$MAIN_JNTP, NL)
  ENDFOR
END print_joint_trajectory

  --------------------------------------------------------------------
  --- Routine: print_joint_trajectory
  --- Brief: Prints all points of a PATH variable
  --------------------------------------------------------------------
ROUTINE print_cartesian_trajectory(trajectory: PATH of POSE_NODE)
VAR
  t_i: INTEGER
BEGIN
  WRITE vs_screen_lun (cs_main_log, 'Trajectory :', NL)
  FOR t_i := 1 TO PATH_LEN(trajectory) DO
    WRITE vs_screen_lun (cs_main_log, 'Cart Traj Point ', t_i ,' ', trajectory.NODE[t_i].$MAIN_POS, NL)
  ENDFOR
END print_cartesian_trajectory


  ------------------------------------------------------------------
  --- Routine: receive_motion_message
  --- Brief: Receiving the motion command and send it for execution
  ------------------------------------------------------------------
ROUTINE receive_motion_message : BOOLEAN
VAR
  t_i : INTEGER
  t_msg : MOTION_MESSAGE_TYPE
  t_joint_pos : JOINTPOS
  t_position : POSITION
BEGIN

  READ vi_server_netlun (t_msg.id::4)        -- Read the motion message unique identifier
  READ vi_server_netlun (t_msg.message_type::1) -- Read the message type identifier

  SELECT t_msg.message_type OF
    CASE('M'):  -- Motion case
      READ vi_server_netlun (t_msg.motion_type::1) -- Read the type of motion
      ss_motion_type := t_msg.motion_type
      SELECT t_msg.motion_type OF
        CASE ('J'):-- Joint Trajectory motion case
          IF ms_state = 'R' THEN
            READ vi_server_netlun (t_msg.linear_velocity::4, t_msg.trajectory_size::4)
            -- Decode the trajectory into PATH variable
            FOR t_i := 1 TO t_msg.trajectory_size DO
              READ vi_server_netlun (t_msg.joint_traj_point[1]::4, t_msg.joint_traj_point[2]::4, t_msg.joint_traj_point[3]::4, t_msg.joint_traj_point[4]::4, t_msg.joint_traj_point[5]::4, t_msg.joint_traj_point[6]::4)
              JNT(t_joint_pos, t_msg.joint_traj_point[1], t_msg.joint_traj_point[2], t_msg.joint_traj_point[3], t_msg.joint_traj_point[4], t_msg.joint_traj_point[5], t_msg.joint_traj_point[6])
              IF append_to_joint_trajectory(t_joint_pos, t_msg.linear_velocity, t_i, t_msg.trajectory_size) = FALSE THEN
                throw_error("Append new joint to trajectory failed")
                RETURN(FALSE)
              ENDIF
            ENDFOR
            -- Ready to execute the decoded trajectory
            ms_state := 'M'
            sb_enable_robot := TRUE
          ELSE
            WRITE vs_screen_lun (cs_main_log,"Joint Trajectory motion command rejected. Robot is already moving", NL)
          ENDIF
        CASE ('C'): -- Cartesian Trajectory motion case
          IF ms_state = 'R' THEN
            READ vi_server_netlun (t_msg.linear_velocity::4, t_msg.trajectory_size::4)
            -- Decode the trajectory into PATH variable
            FOR t_i := 1 TO t_msg.trajectory_size DO
              READ vi_server_netlun (t_msg.cart_traj_point[1]::4, t_msg.cart_traj_point[2]::4, t_msg.cart_traj_point[3]::4, t_msg.cart_traj_point[4]::4, t_msg.cart_traj_point[5]::4, t_msg.cart_traj_point[6]::4)
              t_position := POS(t_msg.cart_traj_point[1], t_msg.cart_traj_point[2], t_msg.cart_traj_point[3], t_msg.cart_traj_point[4], t_msg.cart_traj_point[5], t_msg.cart_traj_point[6])
              POS_SET_RPY(t_position, t_msg.cart_traj_point[4], t_msg.cart_traj_point[5], t_msg.cart_traj_point[6])
              IF append_to_cartesian_trajectory(t_position, t_msg.linear_velocity, t_i, t_msg.trajectory_size) = FALSE THEN
                throw_error("Append new joint to trajectory failed")
                RETURN(FALSE)
              ENDIF
            ENDFOR
            -- Ready to execute the decoded trajectory
            ms_state := 'M'
            sb_enable_robot := TRUE
          ELSE
            WRITE vs_screen_lun (cs_main_log,"Cartesian Trajectory motion command rejected. Robot is already moving", NL)
          ENDIF
        CASE ('S'): -- Sensor Tracking motion case
          IF (ms_state = 'R') OR (ms_state = 'M') THEN
            -- Read the cartesian correction
            WAIT sem_exec

            FOR t_i :=1 TO 6 DO
              READ vi_server_netlun (t_msg.sensor_tracking_correction[t_i]::4)
              sar_cartesian_correction[t_i] := t_msg.sensor_tracking_correction[t_i]
            ENDFOR
            IF first_snstrk = TRUE THEN
              WRITE vs_screen_lun (cs_main_log, 'First SENSOR TRACK COMMAND', NL)
              ms_state := 'R'
              sb_enable_robot := TRUE
              first_snstrk := FALSE
            ELSE
              ms_state := 'M'
            ENDIF
            SIGNAL sem_exec
          ELSE
            WRITE vs_screen_lun (cs_main_log,"Sensor tracking motion command rejected. Robot is in error state", NL)
          ENDIF
        ELSE:
          throw_error("Wrong motion type")
          sb_reset_motion := TRUE
          RETURN(FALSE)
      ENDSELECT
    CASE('T'):  -- Terminate all server case
      sb_terminate := TRUE
      shutdown := TRUE
      RETURN(TRUE)
    CASE('R'):  -- Reset : Cancel all motions -> reset
      ss_motion_type := 'R'
      sb_reset_motion := TRUE
      sb_terminate := FALSE
      RETURN(TRUE)
    ELSE:
      throw_error("Wrong message type")
      sb_reset_motion := TRUE
      RETURN(FALSE)
  ENDSELECT
  RETURN(TRUE)
END receive_motion_message


  ------------------
  ---- MAIN LOOP
  ------------------
BEGIN
  vb_comm_success := TRUE       -- init communication status flag
  vs_server_host := $NET_L[1]   -- get IP from controller settings
  vs_screen_lun := LUN_CRT      -- define output

  sb_reset_motion := FALSE
  sb_terminate := FALSE
  sb_enable_robot := FALSE
  first_snstrk := TRUE

  WRITE vs_screen_lun (NL, "------", NL, 'Robot Motion Server starting... ', NL)

  -- opens the socket
  OPEN FILE vi_server_netlun ('NETT:', 'rw'),
    WITH $FL_BINARY = TRUE,
  ENDOPEN

  -- Initialize semaphore
  CANCEL sem_exec
  SIGNAL sem_exec

  IF VAR_UNINIT(shutdown) THEN
    WRITE LUN_CRT (cs_main_log, 'Initialize shutdown to FALSE', NL)
    shutdown := FALSE -- FALSE
  ENDIF
  first_snstrk := TRUE
  REPEAT

    WRITE vs_screen_lun (cs_main_log, "Server Address : ", vs_server_host, NL)
    WRITE vs_screen_lun (cs_main_log, "Server Port    :", ci_local_port, NL)
    WRITE vs_screen_lun (cs_main_log, "Waiting for connections...", NL)

    ms_state := 'R' -- READY state

    tcp_server_accept((vi_server_netlun), ci_local_port, vs_screen_lun, ci_verbose, cs_main_log)
    WRITE vs_screen_lun (cs_main_log, "Starting cycle...", NL)

    WHILE ms_state <> 'T' DO

      vb_comm_success := receive_motion_message

    ENDWHILE -- Terminate while

    WRITE vs_screen_lun (cs_main_log, "Connection closed.", NL)

    DELAY 500

  UNTIL shutdown   -- Main loop

  CLOSE FILE vi_server_netlun

END motion_server
